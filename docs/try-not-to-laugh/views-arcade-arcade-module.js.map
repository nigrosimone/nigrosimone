{"version":3,"sources":["./src/app/shared/components/youtube-player-wrapper/youtube-player-wrapper.module.ts","./src/app/features/home/views/arcade/arcade-routing.module.ts","./node_modules/@angular/youtube-player/__ivy_ngcc__/fesm2015/youtube-player.js","./src/app/features/home/views/arcade/arcade.module.ts","./src/app/shared/components/youtube-player-wrapper/youtube-player-wrapper.component.ts","./src/app/shared/components/youtube-player-wrapper/youtube-player-wrapper.component.html","./src/app/shared/utils/youtube-api.ts","./src/app/features/home/views/arcade/arcade.component.ts","./src/app/features/home/views/arcade/arcade.component.html"],"names":[],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACoC;AACrB;;AAavD,MAAM,0BAA0B;;yGAA1B,0BAA0B;8KAA1B,0BAA0B,kBAR5B;YACP,4DAAY;YACZ,2EAAmB;SACpB;mIAKU,0BAA0B,mBATtB,+FAA6B,aAE1C,4DAAY;QACZ,2EAAmB,aAGnB,+FAA6B;;;;;;;;;;;;;ACZjC;AAAA;AAAA;AAAA;AAAA;AAAuD;AACF;;;AAErD,MAAM,MAAM,GAAW;IACrB;QACE,IAAI,EAAE,EAAE;QACR,SAAS,EAAE,iEAAe;KAC3B;CACF,CAAC;AAMK,MAAM,mBAAmB;;kGAAnB,mBAAmB;gKAAnB,mBAAmB,kBAHrB,CAAC,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAC9B,4DAAY;mIAEX,mBAAmB,uFAFpB,4DAAY;;;;;;;;;;;;;ACbxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuJ;AACnG;AAC0D;AACuF;;AAErM;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAAO;AAC5C,8BAA8B,4CAAO;AACrC,kCAAkC,oDAAe;AACjD,4BAA4B,oDAAe;AAC3C,2BAA2B,oDAAe;AAC1C,0BAA0B,oDAAe;AACzC,iCAAiC,oDAAe;AAChD,+BAA+B,oDAAe;AAC9C,qCAAqC,oDAAe;AACpD,+BAA+B,oDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAiB;AAC3C;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4CAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,2DAAI,KAAK,gEAAS;AACrF;AACA;AACA,+KAA+K,0DAAG;AAClL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS,GAAG,gEAAS,mBAAmB,8DAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"views-arcade-arcade-module.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { YoutubePlayerWrapperComponent } from './youtube-player-wrapper.component';\nimport { YouTubePlayerModule } from '@angular/youtube-player';\n\n\n@NgModule({\n  declarations: [YoutubePlayerWrapperComponent],\n  imports: [\n    CommonModule,\n    YouTubePlayerModule\n  ],\n  exports: [\n    YoutubePlayerWrapperComponent\n  ]\n})\nexport class YoutubePlayerWrapperModule { }\n","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { ArcadeComponent } from './arcade.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: ArcadeComponent\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ArcadeRoutingModule { }\n","import { Component, ChangeDetectionStrategy, ViewEncapsulation, NgZone, Inject, PLATFORM_ID, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, tap, mergeMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ɵngcc0 from '@angular/core';\n\nconst _c0 = [\"youtubeContainer\"];\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\nclass YouTubePlayer {\n    constructor(_ngZone, platformId) {\n        this._ngZone = _ngZone;\n        this._youtubeContainer = new Subject();\n        this._destroyed = new Subject();\n        this._playerChanges = new BehaviorSubject(undefined);\n        this._videoId = new BehaviorSubject(undefined);\n        this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n        this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n        this._startSeconds = new BehaviorSubject(undefined);\n        this._endSeconds = new BehaviorSubject(undefined);\n        this._suggestedQuality = new BehaviorSubject(undefined);\n        this._playerVars = new BehaviorSubject(undefined);\n        /** Outputs are direct proxies from the player itself. */\n        this.ready = this._getLazyEmitter('onReady');\n        this.stateChange = this._getLazyEmitter('onStateChange');\n        this.error = this._getLazyEmitter('onError');\n        this.apiChange = this._getLazyEmitter('onApiChange');\n        this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n        this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n        this._isBrowser = isPlatformBrowser(platformId);\n    }\n    /** YouTube Video ID to view */\n    get videoId() { return this._videoId.value; }\n    set videoId(videoId) {\n        this._videoId.next(videoId);\n    }\n    /** Height of video player */\n    get height() { return this._height.value; }\n    set height(height) {\n        this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n    }\n    /** Width of video player */\n    get width() { return this._width.value; }\n    set width(width) {\n        this._width.next(width || DEFAULT_PLAYER_WIDTH);\n    }\n    /** The moment when the player is supposed to start playing */\n    set startSeconds(startSeconds) {\n        this._startSeconds.next(startSeconds);\n    }\n    /** The moment when the player is supposed to stop playing */\n    set endSeconds(endSeconds) {\n        this._endSeconds.next(endSeconds);\n    }\n    /** The suggested quality of the player */\n    set suggestedQuality(suggestedQuality) {\n        this._suggestedQuality.next(suggestedQuality);\n    }\n    /**\n     * Extra parameters used to configure the player. See:\n     * https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters\n     */\n    get playerVars() { return this._playerVars.value; }\n    set playerVars(playerVars) {\n        this._playerVars.next(playerVars);\n    }\n    ngOnInit() {\n        // Don't do anything if we're not in a browser environment.\n        if (!this._isBrowser) {\n            return;\n        }\n        let iframeApiAvailableObs = of(true);\n        if (!window.YT || !window.YT.Player) {\n            if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' +\n                    'Please install the YouTube Player API Reference for iframe Embeds: ' +\n                    'https://developers.google.com/youtube/iframe_api_reference');\n            }\n            const iframeApiAvailableSubject = new Subject();\n            this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n            window.onYouTubeIframeAPIReady = () => {\n                if (this._existingApiReadyCallback) {\n                    this._existingApiReadyCallback();\n                }\n                this._ngZone.run(() => iframeApiAvailableSubject.next(true));\n            };\n            iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n        }\n        // An observable of the currently loaded player.\n        const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._playerVars, this._ngZone).pipe(tap(player => {\n            // Emit this before the `waitUntilReady` call so that we can bind to\n            // events that happen as the player is being initialized (e.g. `onReady`).\n            this._playerChanges.next(player);\n        }), waitUntilReady(player => {\n            // Destroy the player if loading was aborted so that we don't end up leaking memory.\n            if (!playerIsReady(player)) {\n                player.destroy();\n            }\n        }), takeUntil(this._destroyed), publish());\n        // Set up side effects to bind inputs to the player.\n        playerObs.subscribe(player => {\n            this._player = player;\n            if (player && this._pendingPlayerState) {\n                this._initializePlayer(player, this._pendingPlayerState);\n            }\n            this._pendingPlayerState = undefined;\n        });\n        bindSizeToPlayer(playerObs, this._width, this._height);\n        bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n        bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed);\n        // After all of the subscriptions are set up, connect the observable.\n        playerObs.connect();\n    }\n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 11.0.0\n     */\n    createEventsBoundInZone() {\n        return {};\n    }\n    ngAfterViewInit() {\n        this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n    }\n    ngOnDestroy() {\n        if (this._player) {\n            this._player.destroy();\n            window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n        }\n        this._playerChanges.complete();\n        this._videoId.complete();\n        this._height.complete();\n        this._width.complete();\n        this._startSeconds.complete();\n        this._endSeconds.complete();\n        this._suggestedQuality.complete();\n        this._youtubeContainer.complete();\n        this._playerVars.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n    playVideo() {\n        if (this._player) {\n            this._player.playVideo();\n        }\n        else {\n            this._getPendingState().playbackState = 1 /* PLAYING */;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n    pauseVideo() {\n        if (this._player) {\n            this._player.pauseVideo();\n        }\n        else {\n            this._getPendingState().playbackState = 2 /* PAUSED */;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n    stopVideo() {\n        if (this._player) {\n            this._player.stopVideo();\n        }\n        else {\n            // It seems like YouTube sets the player to CUED when it's stopped.\n            this._getPendingState().playbackState = 5 /* CUED */;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n    seekTo(seconds, allowSeekAhead) {\n        if (this._player) {\n            this._player.seekTo(seconds, allowSeekAhead);\n        }\n        else {\n            this._getPendingState().seek = { seconds, allowSeekAhead };\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n    mute() {\n        if (this._player) {\n            this._player.mute();\n        }\n        else {\n            this._getPendingState().muted = true;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n    unMute() {\n        if (this._player) {\n            this._player.unMute();\n        }\n        else {\n            this._getPendingState().muted = false;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n    isMuted() {\n        if (this._player) {\n            return this._player.isMuted();\n        }\n        if (this._pendingPlayerState) {\n            return !!this._pendingPlayerState.muted;\n        }\n        return false;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n    setVolume(volume) {\n        if (this._player) {\n            this._player.setVolume(volume);\n        }\n        else {\n            this._getPendingState().volume = volume;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n    getVolume() {\n        if (this._player) {\n            return this._player.getVolume();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n            return this._pendingPlayerState.volume;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n    setPlaybackRate(playbackRate) {\n        if (this._player) {\n            return this._player.setPlaybackRate(playbackRate);\n        }\n        else {\n            this._getPendingState().playbackRate = playbackRate;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n    getPlaybackRate() {\n        if (this._player) {\n            return this._player.getPlaybackRate();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n            return this._pendingPlayerState.playbackRate;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n    getAvailablePlaybackRates() {\n        return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n    getVideoLoadedFraction() {\n        return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n    getPlayerState() {\n        if (!this._isBrowser || !window.YT) {\n            return undefined;\n        }\n        if (this._player) {\n            return this._player.getPlayerState();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n            return this._pendingPlayerState.playbackState;\n        }\n        return -1 /* UNSTARTED */;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n    getCurrentTime() {\n        if (this._player) {\n            return this._player.getCurrentTime();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n            return this._pendingPlayerState.seek.seconds;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n    getPlaybackQuality() {\n        return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n    getAvailableQualityLevels() {\n        return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n    getDuration() {\n        return this._player ? this._player.getDuration() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n    getVideoUrl() {\n        return this._player ? this._player.getVideoUrl() : '';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n    getVideoEmbedCode() {\n        return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /** Gets an object that should be used to store the temporary API state. */\n    _getPendingState() {\n        if (!this._pendingPlayerState) {\n            this._pendingPlayerState = {};\n        }\n        return this._pendingPlayerState;\n    }\n    /** Initializes a player from a temporary state. */\n    _initializePlayer(player, state) {\n        const { playbackState, playbackRate, volume, muted, seek } = state;\n        switch (playbackState) {\n            case 1 /* PLAYING */:\n                player.playVideo();\n                break;\n            case 2 /* PAUSED */:\n                player.pauseVideo();\n                break;\n            case 5 /* CUED */:\n                player.stopVideo();\n                break;\n        }\n        if (playbackRate != null) {\n            player.setPlaybackRate(playbackRate);\n        }\n        if (volume != null) {\n            player.setVolume(volume);\n        }\n        if (muted != null) {\n            muted ? player.mute() : player.unMute();\n        }\n        if (seek != null) {\n            player.seekTo(seek.seconds, seek.allowSeekAhead);\n        }\n    }\n    /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n    _getLazyEmitter(name) {\n        // Start with the stream of players. This way the events will be transferred\n        // over to the new player if it gets swapped out under-the-hood.\n        return this._playerChanges.pipe(\n        // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n        // player is changed. If there's no player, return an observable that never emits.\n        switchMap(player => {\n            return player ? fromEventPattern((listener) => {\n                player.addEventListener(name, listener);\n            }, (listener) => {\n                // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n                // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n                // prevent the entire stream from erroring out.\n                try {\n                    if (player.removeEventListener) {\n                        player.removeEventListener(name, listener);\n                    }\n                }\n                catch (_a) { }\n            }) : of();\n        }), \n        // By default we run all the API interactions outside the zone\n        // so we have to bring the events back in manually when they emit.\n        (source) => new Observable(observer => source.subscribe({\n            next: value => this._ngZone.run(() => observer.next(value)),\n            error: error => observer.error(error),\n            complete: () => observer.complete()\n        })), \n        // Ensures that everything is cleared out on destroy.\n        takeUntil(this._destroyed));\n    }\n}\nYouTubePlayer.ɵfac = function YouTubePlayer_Factory(t) { return new (t || YouTubePlayer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };\nYouTubePlayer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YouTubePlayer, selectors: [[\"youtube-player\"]], viewQuery: function YouTubePlayer_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 1);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.youtubeContainer = _t.first);\n    } }, inputs: { videoId: \"videoId\", height: \"height\", width: \"width\", startSeconds: \"startSeconds\", endSeconds: \"endSeconds\", suggestedQuality: \"suggestedQuality\", playerVars: \"playerVars\", showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\" }, outputs: { ready: \"ready\", stateChange: \"stateChange\", error: \"error\", apiChange: \"apiChange\", playbackQualityChange: \"playbackQualityChange\", playbackRateChange: \"playbackRateChange\" }, decls: 2, vars: 0, consts: [[\"youtubeContainer\", \"\"]], template: function YouTubePlayer_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", null, 0);\n    } }, encapsulation: 2, changeDetection: 0 });\nYouTubePlayer.ctorParameters = () => [\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nYouTubePlayer.propDecorators = {\n    videoId: [{ type: Input }],\n    height: [{ type: Input }],\n    width: [{ type: Input }],\n    startSeconds: [{ type: Input }],\n    endSeconds: [{ type: Input }],\n    suggestedQuality: [{ type: Input }],\n    playerVars: [{ type: Input }],\n    showBeforeIframeApiLoads: [{ type: Input }],\n    ready: [{ type: Output }],\n    stateChange: [{ type: Output }],\n    error: [{ type: Output }],\n    apiChange: [{ type: Output }],\n    playbackQualityChange: [{ type: Output }],\n    playbackRateChange: [{ type: Output }],\n    youtubeContainer: [{ type: ViewChild, args: ['youtubeContainer',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YouTubePlayer, [{\n        type: Component,\n        args: [{\n                selector: 'youtube-player',\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                // This div is *replaced* by the YouTube player embed.\n                template: '<div #youtubeContainer></div>'\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ready: [{\n            type: Output\n        }], stateChange: [{\n            type: Output\n        }], error: [{\n            type: Output\n        }], apiChange: [{\n            type: Output\n        }], playbackQualityChange: [{\n            type: Output\n        }], playbackRateChange: [{\n            type: Output\n        }], videoId: [{\n            type: Input\n        }], height: [{\n            type: Input\n        }], width: [{\n            type: Input\n        }], startSeconds: [{\n            type: Input\n        }], endSeconds: [{\n            type: Input\n        }], suggestedQuality: [{\n            type: Input\n        }], playerVars: [{\n            type: Input\n        }], showBeforeIframeApiLoads: [{\n            type: Input\n        }], youtubeContainer: [{\n            type: ViewChild,\n            args: ['youtubeContainer']\n        }] }); })();\n/** Listens to changes to the given width and height and sets it on the player. */\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n    return combineLatest([playerObs, widthObs, heightObs])\n        .subscribe(([player, width, height]) => player && player.setSize(width, height));\n}\n/** Listens to changes from the suggested quality and sets it on the given player. */\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n    return combineLatest([\n        playerObs,\n        suggestedQualityObs\n    ]).subscribe(([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n */\nfunction waitUntilReady(onAbort) {\n    return mergeMap(player => {\n        if (!player) {\n            return of(undefined);\n        }\n        if (playerIsReady(player)) {\n            return of(player);\n        }\n        // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n        // The player is not initialized fully until the ready is called.\n        return new Observable(emitter => {\n            let aborted = false;\n            let resolved = false;\n            const onReady = (event) => {\n                resolved = true;\n                if (!aborted) {\n                    event.target.removeEventListener('onReady', onReady);\n                    emitter.next(event.target);\n                }\n            };\n            player.addEventListener('onReady', onReady);\n            return () => {\n                aborted = true;\n                if (!resolved) {\n                    onAbort(player);\n                }\n            };\n        }).pipe(take(1), startWith(undefined));\n    });\n}\n/** Create an observable for the player based on the given options. */\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, playerVarsObs, ngZone) {\n    const playerOptions = combineLatest([videoIdObs, playerVarsObs]).pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map(([constructorOptions, sizeOptions]) => {\n        const [videoId, playerVars] = constructorOptions;\n        const [width, height] = sizeOptions;\n        return videoId ? ({ videoId, playerVars, width, height }) : undefined;\n    }));\n    return combineLatest([youtubeContainer, playerOptions, of(ngZone)])\n        .pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/** Skips the given observable until the other observable emits true, then emit the latest. */\nfunction skipUntilRememberLatest(notifier) {\n    return pipe(combineLatest$1(notifier), skipWhile(([_, doneSkipping]) => !doneSkipping), map(([value]) => value));\n}\n/** Destroy the player if there are no options, or create the player if there are options. */\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n    if (player && videoOptions && player.playerVars !== videoOptions.playerVars) {\n        // The player needs to be recreated if the playerVars are different.\n        player.destroy();\n    }\n    else if (!videoOptions) {\n        if (player) {\n            // Destroy the player if the videoId was removed.\n            player.destroy();\n        }\n        return;\n    }\n    else if (player) {\n        return player;\n    }\n    // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n    // off a 250ms setInterval which will continually trigger change detection if we don't.\n    const newPlayer = ngZone.runOutsideAngular(() => new YT.Player(container, videoOptions));\n    newPlayer.videoId = videoOptions.videoId;\n    newPlayer.playerVars = videoOptions.playerVars;\n    return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n */\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n    const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs])\n        .pipe(map(([startSeconds, endSeconds]) => ({ startSeconds, endSeconds })));\n    // Only respond to changes in cue options if the player is not running.\n    const filteredCueOptions = cueOptionsObs\n        .pipe(filterOnOther(playerObs, player => !!player && !hasPlayerStarted(player)));\n    // If the video id changed, there's no reason to run 'cue' unless the player\n    // was initialized with a different video id.\n    const changedVideoId = videoIdObs\n        .pipe(filterOnOther(playerObs, (player, videoId) => !!player && player.videoId !== videoId));\n    // If the player changed, there's no reason to run 'cue' unless there are cue options.\n    const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), ([videoId, cueOptions], player) => !!player &&\n        (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds)));\n    merge(changedPlayer, changedVideoId, filteredCueOptions)\n        .pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map(([_, values]) => values), takeUntil(destroyed))\n        .subscribe(([player, videoId, cueOptions, suggestedQuality]) => {\n        if (!videoId || !player) {\n            return;\n        }\n        player.videoId = videoId;\n        player.cueVideoById(Object.assign({ videoId,\n            suggestedQuality }, cueOptions));\n    });\n}\nfunction hasPlayerStarted(player) {\n    const state = player.getPlayerState();\n    return state !== -1 /* UNSTARTED */ && state !== 5 /* CUED */;\n}\nfunction playerIsReady(player) {\n    return 'getPlayerStatus' in player;\n}\n/** Combines the two observables temporarily for the filter function. */\nfunction filterOnOther(otherObs, filterFn) {\n    return pipe(withLatestFrom(otherObs), filter(([value, other]) => filterFn(other, value)), map(([value]) => value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst COMPONENTS = [YouTubePlayer];\nclass YouTubePlayerModule {\n}\nYouTubePlayerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: YouTubePlayerModule });\nYouTubePlayerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function YouTubePlayerModule_Factory(t) { return new (t || YouTubePlayerModule)(); } });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(YouTubePlayerModule, { declarations: [YouTubePlayer], exports: [YouTubePlayer] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YouTubePlayerModule, [{\n        type: NgModule,\n        args: [{\n                declarations: COMPONENTS,\n                exports: COMPONENTS\n            }]\n    }], null, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { YouTubePlayer, YouTubePlayerModule };\n\n//# sourceMappingURL=youtube-player.js.map","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ArcadeComponent } from './arcade.component';\nimport { ArcadeRoutingModule } from './arcade-routing.module';\nimport { HumanizeTimeModule } from 'src/app/shared/pipe/humanize-time/humanize-time.module';\nimport { CameraDetectionModule } from 'src/app/shared/components/camera-detection/camera-detection.module';\nimport { YoutubePlayerWrapperModule } from 'src/app/shared/components/youtube-player-wrapper/youtube-player-wrapper.module';\n\n@NgModule({\n  declarations: [ArcadeComponent],\n  imports: [\n    CommonModule,\n    ArcadeRoutingModule,\n    HumanizeTimeModule,\n    CameraDetectionModule,\n    YoutubePlayerWrapperModule\n  ],\n  exports: [\n    ArcadeComponent\n  ]\n})\nexport class ArcadeModule { }\n","import { ChangeDetectionStrategy, Component, EventEmitter, Input, OnInit, Output, ViewChild } from '@angular/core';\r\nimport { YouTubePlayer } from '@angular/youtube-player';\r\nimport { loadYouTubeApiScript } from '../../utils/youtube-api';\r\n\r\n\r\n@Component({\r\n  selector: 'app-youtube-player-wrapper',\r\n  templateUrl: './youtube-player-wrapper.component.html',\r\n  styleUrls: ['./youtube-player-wrapper.component.scss'],\r\n  changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class YoutubePlayerWrapperComponent implements OnInit {\r\n\r\n  @ViewChild('youtube', { static: false }) youtube: YouTubePlayer;\r\n\r\n  @Input() videoId: string;\r\n  @Input() seek: number;\r\n  @Input() width: number;\r\n  @Input() height: number;\r\n\r\n  @Output() stateChange: EventEmitter<YT.OnStateChangeEvent> = new EventEmitter<YT.OnStateChangeEvent>();\r\n  @Output() ready: EventEmitter<YT.PlayerEvent> = new EventEmitter<YT.PlayerEvent>();\r\n\r\n  private seekChecked = false;\r\n  private seekApplied = false;\r\n\r\n  // impostazioni del player di youtube\r\n  public playerVars: YT.PlayerVars = {\r\n    autoplay: YT.AutoPlay.NoAutoPlay,\r\n    controls: YT.Controls.Hide,\r\n    showinfo: YT.ShowInfo.Hide,\r\n    modestbranding: YT.ModestBranding.Modest,\r\n    rel: YT.RelatedVideos.Hide\r\n  };\r\n\r\n  ngOnInit(): void {\r\n    // carichiamo lo script delle API di youtube\r\n    loadYouTubeApiScript();\r\n  }\r\n\r\n  /**\r\n   * Evento di cambiamento di stato del player di YouTube\r\n   */\r\n  onStateChange(e: YT.OnStateChangeEvent): void {\r\n    if (e.data === YT.PlayerState.PLAYING) {\r\n      if (!this.seekApplied && !this.seekChecked && this.seek > 0) {\r\n        this.seekChecked = true;\r\n        if (this.seek < this.youtube.getDuration()) {\r\n          this.youtube.seekTo(this.seek, true);\r\n          this.seekApplied = true;\r\n        }\r\n      }\r\n    }\r\n    this.stateChange.emit(e);\r\n  }\r\n\r\n  /**\r\n   * Mette in pausa la webcam\r\n   */\r\n  pauseVideo(): void {\r\n    this.youtube.pauseVideo();\r\n  }\r\n\r\n  /**\r\n   * Mette in play la webcam\r\n   */\r\n  playVideo(): void {\r\n    this.youtube.playVideo();\r\n  }\r\n\r\n  /**\r\n   * Ferma il video\r\n   */\r\n  stopVideo(): void {\r\n    this.youtube.stopVideo();\r\n  }\r\n\r\n  /**\r\n   * Torna i secondi visualizzati del video\r\n   */\r\n  getCurrentTime(): number {\r\n    return this.youtube.getCurrentTime();\r\n  }\r\n\r\n  /**\r\n   * Torna i secondi visualizzati del video come intero\r\n   */\r\n  getCurrentTimeInt(): number {\r\n    return Math.floor(this.getCurrentTime());\r\n  }\r\n\r\n  /**\r\n   * Torna i secondi visualizzati del video come intero meno i secondi del seek\r\n   */\r\n  getCurrentTimeIntSeeked(): number {\r\n    let time = this.getCurrentTimeInt();\r\n    if (this.seekApplied) {\r\n      time = time - this.seek;\r\n    }\r\n    return time;\r\n  }\r\n}\r\n","<youtube-player [width]=\"width\" [height]=\"height\" [videoId]=\"videoId\" [playerVars]=\"playerVars\" (ready)=\"ready.emit($event)\"\r\n(stateChange)=\"onStateChange($event)\" #youtube></youtube-player>","\r\n/**\r\n * Carica lo script per le API del player di YouTube\r\n */\r\nexport function loadYouTubeApiScript(): void {\r\n    const ID = 'YOUTUBE_API_SCRIPT';\r\n    let el = document.getElementById(ID) as HTMLScriptElement;\r\n    if (!el) {\r\n      // This code loads the IFrame Player API code asynchronously, according to the instructions at\r\n      // https://developers.google.com/youtube/iframe_api_reference#Getting_Started\r\n      el = document.createElement('script');\r\n      el.src = 'https://www.youtube.com/iframe_api';\r\n      el.id = ID;\r\n      document.body.appendChild(el);\r\n    }\r\n}\r\n","import { ChangeDetectorRef, Component, ElementRef, OnDestroy, OnInit, ViewChild, ChangeDetectionStrategy } from '@angular/core';\r\nimport * as faceapi from 'face-api.js';\r\nimport { Subscription } from 'rxjs';\r\nimport { WindowService } from 'src/app/core/services/window/windos.service';\r\nimport { CameraDetectionComponent } from 'src/app/shared/components/camera-detection/camera-detection.component';\r\nimport { YoutubePlayerWrapperComponent } from 'src/app/shared/components/youtube-player-wrapper/youtube-player-wrapper.component';\r\nimport { randomItemFromArray, safeUnsubscribe } from 'src/app/shared/utils/common';\r\n\r\nconst VIDEOS = ['_TnkkZq-dbU', 'g6PSwYx3jA0', 'pl0KA-wPT8A'];\r\n\r\n@Component({\r\n  selector: 'app-arcade',\r\n  templateUrl: './arcade.component.html',\r\n  styleUrls: ['./arcade.component.scss']\r\n})\r\nexport class ArcadeComponent implements OnInit, OnDestroy {\r\n\r\n  @ViewChild('cameraDetection', { static: false }) cameraDetection: CameraDetectionComponent;\r\n  @ViewChild('youtube', { static: false }) youtube: YoutubePlayerWrapperComponent;\r\n\r\n  // id del video di youtube\r\n  public videoId = randomItemFromArray<string>(VIDEOS);\r\n\r\n  // true se l'espressione facciale è stata trovata nella webcam\r\n  public faceDetected = false;\r\n  // se true l'espressione facciale è stata trovata almeno una volta\r\n  public firstDetectionHappen = false;\r\n  // se true il riconoscimento facciale è pronto\r\n  public detectionReady = false;\r\n\r\n  // se true youtube e il riconoscimento facciale sono pronti\r\n  public allReady = false;\r\n\r\n  // partita terminata\r\n  public endMatch = false;\r\n  // partita terminata come persa\r\n  public loseMatch = false;\r\n  // partita terminata come vinta\r\n  public winMatch = false;\r\n\r\n  // valore di felicità dell'espressione facciale\r\n  public happy = 0;\r\n\r\n  // true se la partita può iniziare\r\n  public readyToGame = false;\r\n\r\n  // true se il player video di youtube è stato caricato\r\n  public youtubeReady = false;\r\n\r\n  // secondi visti del video di youtube\r\n  public timeElapse = 0;\r\n\r\n  // massimo di secondi visti del video di youtube\r\n  public recordDuration = 0;\r\n\r\n  // dimensioni dell'area di gioco\r\n  public width = 0;\r\n  public height = 0;\r\n\r\n  private subVwChanges: Subscription;\r\n\r\n  constructor(\r\n    private cdr: ChangeDetectorRef,\r\n    private windowService: WindowService,\r\n    private elRef: ElementRef) {\r\n    this.recordDuration = this.getRecordStorageDuration();\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this.subVwChanges = this.windowService.viewPortChanges.subscribe(() => {\r\n      this.doResize();\r\n    });\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    safeUnsubscribe(this.subVwChanges);\r\n  }\r\n\r\n  /**\r\n   * Evento di cambiamento di stato del player di YouTube\r\n   */\r\n  onStateChange(e: YT.OnStateChangeEvent): void {\r\n    if (e.data === YT.PlayerState.ENDED) {\r\n      this.endGame(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evento di caricamento completato del player di YouTube\r\n   */\r\n  onYoutubeReady(e: YT.PlayerEvent): void {\r\n    this.youtubeReady = true;\r\n    this.doThirdPartyOnReady();\r\n  }\r\n\r\n  /**\r\n   * Evento di caricamento completato del riconoscimento facciale\r\n   */\r\n  onDetectionReady(e: boolean): void {\r\n    this.detectionReady = true;\r\n    this.doThirdPartyOnReady();\r\n  }\r\n\r\n  /**\r\n   * Quando il player youtube o il riconoscimento sono ready, gestiamo le parti comuni\r\n   */\r\n  doThirdPartyOnReady(): void {\r\n    this.allReady = this.youtubeReady && this.detectionReady;\r\n    this.doResize();\r\n  }\r\n\r\n  /**\r\n   * Evento scatenato al primo riconoscimento facciale\r\n   */\r\n  onFirstDetection(e: boolean): void {\r\n    this.firstDetectionHappen = e;\r\n  }\r\n\r\n  /**\r\n   * Evento ad ogni cambiamento di stato (trovata/non trovata la faccia)\r\n   */\r\n  onDetectionFace(e: boolean): void {\r\n    this.faceDetected = e;\r\n  }\r\n\r\n  /**\r\n   * Evento di cambiamento del riconoscimento facciale\r\n   */\r\n  onDetectionChanges(e: faceapi.FaceExpressions): void {\r\n\r\n    // ridimensioniamo l'area di gioco\r\n    this.doResize();\r\n\r\n    // se il player di youtube non  è pronto non facciamo nient'altro\r\n    if (!this.youtubeReady) {\r\n      return;\r\n    }\r\n\r\n    // faccia trovata?\r\n    if (e) {\r\n      const happy = e.happy;\r\n      if (this.happy !== happy) {\r\n        this.happy = happy;\r\n        this.cdr.markForCheck();\r\n      }\r\n      // se la felicità è maggiore di ... ha perso\r\n      if (this.happy > 0.8) {\r\n        this.endGame(false);\r\n        return;\r\n      }\r\n    } else {\r\n      // faccia non trovata...\r\n      this.happy = 0;\r\n    }\r\n\r\n    // recuperiamo il tempo di esecuzione del video di youtube\r\n    const timeElapse = this.youtube.getCurrentTimeIntSeeked();\r\n    if (this.timeElapse !== timeElapse) {\r\n      this.timeElapse = timeElapse;\r\n    }\r\n\r\n    this.manageDetectionState();\r\n  }\r\n\r\n  /**\r\n   * Gestisce lo stato di ricerca della faccia nello stream video\r\n   */\r\n  manageDetectionState(): void {\r\n    this.manageReadyToGameState();\r\n    // se non abbiamo la faccia, mettiamo anche in pausa il video di youtube,\r\n    // questo perchè il video parte in autoplay la prima volta\r\n    if (!this.faceDetected || !document.hasFocus()) {\r\n      this.youtube.pauseVideo();\r\n    } else {\r\n      this.youtube.playVideo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Termina la partita\r\n   */\r\n  endGame(userWin: boolean): void {\r\n    if (!this.endMatch) {\r\n      this.winMatch = userWin;\r\n      this.loseMatch = !this.winMatch;\r\n      this.endMatch = true;\r\n      // mettiamo in pausa il video della webcam\r\n      this.cameraDetection.pauseVideo();\r\n      // fermiamo il video di youtube\r\n      this.youtube.stopVideo();\r\n      // facciamo vibrare il cellulare\r\n      window.navigator.vibrate(200);\r\n      this.manageReadyToGameState();\r\n      this.cdr.markForCheck();\r\n      this.setLocalStorageDuration(this.timeElapse);\r\n    }\r\n  }\r\n\r\n  restartGame(): void {\r\n      this.endMatch = false;\r\n      // riavviamo il video della webcam\r\n      this.cameraDetection.playVideo();\r\n      this.manageReadyToGameState();\r\n      this.recordDuration = this.getRecordStorageDuration();\r\n      this.cdr.markForCheck();\r\n  }\r\n\r\n  /**\r\n   * Gestisce lo stato della partita (se è pronta per essere giocata o meno)\r\n   */\r\n  manageReadyToGameState(): void {\r\n    // può essere giocata se non è terminata e se abbiamo trovato la faccia\r\n    const readyToGame = !this.endMatch && this.faceDetected;\r\n    if (this.readyToGame !== readyToGame) {\r\n      this.readyToGame = readyToGame;\r\n      this.cdr.markForCheck();\r\n    }\r\n  }\r\n\r\n  doResize(): void {\r\n    // -1 altrimenti esce la scrollbar\r\n    const w = this.elRef.nativeElement.clientWidth - 1;\r\n    const h = this.elRef.nativeElement.clientHeight - 1;\r\n\r\n    if (w !== this.width || h !== this.height) {\r\n      this.width = w;\r\n      this.height = h;\r\n      this.cdr.markForCheck();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recupera dal localstorage l'ultima durata del video corrente\r\n   */\r\n  getLocalStorageDuration(): number {\r\n    return +localStorage.getItem(`arcade-${this.videoId}-duration`);\r\n  }\r\n\r\n  /**\r\n   * Setta nel localstorage l'ultima durata del video corrente\r\n   */\r\n  setLocalStorageDuration(value: number): void {\r\n    localStorage.setItem(`arcade-${this.videoId}-duration`, value.toString());\r\n    this.setRecordStorageDuration(value);\r\n  }\r\n\r\n  /**\r\n   * Recupera il valore record\r\n   */\r\n  getRecordStorageDuration(): number{\r\n    return +localStorage.getItem(`arcade-record-duration`);\r\n  }\r\n\r\n  /**\r\n   * Setta il valore del record\r\n   */\r\n  setRecordStorageDuration(value: number): void {\r\n    const key = `arcade-record-duration`;\r\n    const record: number = +localStorage.getItem(key);\r\n    if (value > record) {\r\n      localStorage.setItem(key, value.toString());\r\n    }\r\n  }\r\n}\r\n","<div class=\"game-container\" [style.width]=\"width + 'px'\" [style.height]=\"height + 'px'\">\r\n    <div class=\"info\">\r\n        <div *ngIf=\"endMatch\" class=\"retry\"><button class=\"retry-button\" (click)=\"restartGame()\"><h1>RIPROVA</h1></button></div>\r\n        <h1 *ngIf=\"endMatch && loseMatch\">Hai perso, hai sorriso!</h1>\r\n        <h1 *ngIf=\"endMatch && winMatch\">Hai vinto, non hai sorriso!</h1>\r\n        <h1 *ngIf=\"detectionReady && !endMatch && !faceDetected\">Non riesco a vedere la tua faccia!</h1>\r\n        <div class=\"badge-container\" *ngIf=\"faceDetected || endMatch\">\r\n            <span class=\"badge badge-happy\" [style.background]=\"happy > 0.3 ? 'red' : 'green'\">Felicità: {{ (happy * 100) | number:'1.1-1' }}%</span> \r\n            <span class=\"badge badge-duration\" [style.background]=\"timeElapse > recordDuration ? 'green' : 'blue'\">Resistenza: {{ (timeElapse * 1000) | humanizeTime }}</span>\r\n            <span class=\"badge badge-record-duration\" *ngIf=\"recordDuration\">Record: {{ (recordDuration * 1000) | humanizeTime }}</span>\r\n        </div>\r\n    </div>\r\n    <div class=\"youtube\" *ngIf=\"!endMatch\" [style.display]=\"!readyToGame ? 'none': 'flex'\">\r\n        <app-youtube-player-wrapper [width]=\"width\" [height]=\"height\" [videoId]=\"videoId\" [seek]=\"recordDuration\" (ready)=\"onYoutubeReady($event)\"\r\n        (stateChange)=\"onStateChange($event)\" #youtube></app-youtube-player-wrapper>\r\n    </div>\r\n    <div class=\"webcam\" [style.display]=\"readyToGame ? 'none': 'flex'\">\r\n        <app-camera-detection [width]=\"width\" [height]=\"height\" [drawDetection]=\"false\" [detectionTimer]=\"100\" (detectionReady)=\"onDetectionReady($event)\" (detectionChanges)=\"onDetectionChanges($event)\" (firstDetection)=\"onFirstDetection($event)\" (detectionFace)=\"onDetectionFace($event)\" #cameraDetection></app-camera-detection>\r\n    </div>\r\n</div>"],"sourceRoot":"webpack:///"}